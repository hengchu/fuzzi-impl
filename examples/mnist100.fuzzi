db:[1.0] { [float(101)] };
db1: { [float(102)] };
trow: [float(101)];
trow1: [float(102)];

w:      [float(101)];
dws: {[float(101)]};
dws_j: {float};
j_sum: float;
tf_out: float;
twout: [float(101)];

i: int;
clear_idx: int;

dt: float;
temp: float;
prob: float;
sc: float;

size: float;

epoch: int

epoch = 0;

while epoch < 50 do
{
/* Extend each row with a constant 1 for bias */
bmap(db, db1, trow, i, trow1, {
  clear(trow1, clear_idx);
  trow1[0] = 1.0;
  clear_idx = 0;
  clear_idx = 0;
  while clear_idx < 101 do
    { trow1[clear_idx + 1] = trow[clear_idx] };
    clear_idx = clear_idx + 1;
  end;
  clear_idx = 0;
});

i = 0;
clear(trow, i);
i = 0;
clear(trow1, i);
i = 0;

/* Compute the gradient from each row */
bmap(db1, dws, trow1, i, twout, {
  clear(twout, clear_idx);
  clear_idx = 0;

  clear_idx = 0;
  while clear_idx < 101 do
    { twout[clear_idx] = trow1[clear_idx] };
    clear_idx = clear_idx + 1;
  end;
  clear_idx = 0;

  dt = dot(twout, w) / 1000.0;
  temp = clip(exp(-1.0 * trow1[101] * dt), 10000.0);
  prob = 1.0 / (1.0 + temp);
  sc = (1.0 - prob) * trow1[101];
  twout = scale(sc, twout);

  dt = 0.0;
  temp = 0.0;
  prob = 0.0;
  sc = 0.0;
  clear_idx = 0;
});

/* Release the size of the db, for normalizing gradients */
size $= lap(1.0, fc(length(db)));

clear(twout, clear_idx);
clear_idx = 0;

/* Project out each column of the gradient, sum up, and release */
clear_idx = 0;
while clear_idx < 101 do
  {
    bmap(dws, dws_j, twout, i, tf_out, { tf_out = twout[clear_idx]; });
    i = 0;
    tf_out = 0.0;
    bsum(dws_j, j_sum, i, tf_out, 1.0);
    j_sum $= lap(1.0, j_sum);

    w[clear_idx] = w[clear_idx] + j_sum / size;
  };
  clear_idx = clear_idx + 1;
end
};
epoch = epoch + 1
end
